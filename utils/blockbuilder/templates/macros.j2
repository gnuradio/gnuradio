{% macro header() -%}
/*
 * This file is part of GNU Radio
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 *
 */

/************************************************************/
/* This file is AUTOMATICALLY GENERATED using blockbuilder  */
/*       and should not manually edited                     */
/************************************************************/
{% endmacro %}

{% macro includes(includes) -%}
{% for incl in includes %}
#include <{{incl}}>
{% endfor %}
{% endmacro %}

{% macro blocktype(properties) -%}
{% set blocktype = 'sync' if properties|selectattr("id", "equalto", "blocktype")|map(attribute='value')|first == 'sync' else 'general' -%}
{% if blocktype == 'sync' -%}
#include <gnuradio/sync_block.h>
{% elif blocktype == 'general' -%}
#include <gnuradio/block.h>
{% endif -%}
{% endmacro %}

{% macro class_statement(block, blocktype) -%}
class {{ block }} : virtual public {{blocktype}}{#{{',' if inherits != ''}}  {{ inherits }}#}
{% endmacro %}

{% macro get_linked_value(value, ports, parameters, typekeys, enums) -%}
    {% set newvalue = value -%}
    {% if '/' in value | string() -%}
    {% set list1 = value.split('/') -%}
    {% set category = list1[0] -%}
        {% if category == 'ports' -%}
            {% set newvalue = list1[1] -%}
        {% elif category == 'parameters' -%}
            {% set newvalue = 'args.' + list1[1] -%}
        {% elif category == 'typekeys' -%}
            {% set newvalue = list1[1] -%}
        {% elif category == 'enums' -%}
            {% set newvalue = list1[1] -%}
        {% endif -%}
    {% endif -%}
{{newvalue}}{% endmacro -%}

{% macro block_args(parameters) -%}
    struct block_args {
        {% if parameters %} {% for param in parameters -%}{% if 'cotr' not in param or param['cotr'] == true %}
        {% if param['container'] == 'vector' -%}
        std::vector<{{ param['dtype'] }}> {{ param['id'] }}{% if 'default' in param %} = {{param['default']}}{% endif %};
        {% else %}
        {{get_linked_value(param['dtype']) }} {{ param['id'] }}{% if 'default' in param %} = {{param['default']}}{% endif %};
        {% endif %}
        {% endif %}{% endfor -%}{% endif %}};
{% endmacro %}

{% macro cotr_statement(block) -%}
{{ block }}(const block_args& args);
{% endmacro %}



{% macro ports(ports, parameters, typekeys) -%}
        {% for port in ports %}
        {% set porttype = get_linked_value(port['type']) -%}
        {% if port['domain'] != 'message' -%}
        {% if port['type'] == 'untyped'%}   
        for (size_t i = 0; i < {{ get_linked_value(port['multiplicity'])}}; i++) {
        add_port(untyped_port::make(
            "{{ port['id'] }}" {{ "+ std::to_string(i)" if get_linked_value(port['multiplicity'])|int() > 1}}, 
            {{ 'port_direction_t::INPUT' if port['direction'] == "input" else 'port_direction_t::OUTPUT' }}, 
            {{ get_linked_value(port['size'])}}, {{port['optional']|lower()}}));
        }
        {% else %}
        for (size_t i = 0; i < {{ get_linked_value(port['multiplicity'])}}; i++) {
        add_port(port<{{porttype}}>::make("{{ port['id'] }}" {{ "+ std::to_string(i)" if get_linked_value(port['multiplicity'])|int() > 1}}, 
                            {{ 'port_direction_t::INPUT' if port['direction'] == "input" else 'port_direction_t::OUTPUT' }},
                            std::vector<size_t>{ {{ get_linked_value(port['shape'])}} }, {{port['optional']|lower()}}));
        }
        {% endif %}
        {% else %}
        {% if port['direction'] == 'input' %}
        auto msg_{{port['id']}} = message_port::make(
            "{{port['id']}}", port_direction_t::INPUT, {{port['optional']|lower()}});
        msg_{{port['id']}}->register_callback([this](pmtf::pmt msg) { this->handle_msg_{{port['id']}}(msg); });
        {% else %}
        auto msg_{{port['id']}} = message_port::make(
            "{{port['id']}}", port_direction_t::OUTPUT, {{port['optional']|lower()}});
        {% endif %}
        add_port(std::move(msg_{{port['id']}}));
        d_msg_{{port['id']}} = this->get_message_port("{{port['id']}}");
        {% endif -%}
        {% endfor %}
{% endmacro %}

{% macro implementations(implementations) -%}
    enum class available_impl { {% for impl in implementations %}{{ impl['id'] | upper }},{% endfor %} PYSHELL };
    static sptr make(const block_args& args, available_impl impl = available_impl::{{implementations[0]['id'] | upper }});
    static sptr make_from_params(const std::string& json_str, available_impl impl = available_impl::{{implementations[0]['id'] | upper }});

    {% set vars = {'pyshell': False} %}
    {% for impl in implementations %}
    {% if 'lang' not in impl or impl['lang'] == 'cpp' -%}
    /**
     * @brief Set the implementation to {{ impl['id'] | upper }} and return a shared pointer to the block instance
     * 
     * @return std::shared_ptr<{{ block }}> 
     */
    static sptr make_{{impl['id']}}(const block_args& args);
    {% elif 'lang' in impl and impl['lang'] == 'python' and not vars.pyshell -%}
    static sptr make_pyshell(const block_args& args);
    {% if vars.update({'pyshell': True}) %} {% endif %}
    {% endif -%}
    {% endfor %}


{% endmacro %}

{% macro callbacks(callbacks) -%}
    {% for cb in callbacks -%}
    {% if 'inherited' not in cb or not cb['inherited'] -%}
    virtual  {{cb['return']}} {{cb['id']}} (
    {% if 'args' in cb -%}
    {% for arg in cb['args'] -%}
    {{get_linked_value(arg['dtype'])}} {{arg['id']}}{{ ", " if not loop.last }}
    {% endfor -%}
    {% endif -%}
    ) {% if cb['const'] %}const {%endif%} = 0;
    {% endif -%}
    {% endfor %} 
{% endmacro %}

{% macro message_ports(ports) -%}
    {% for port in ports %}{% if port['domain'] == 'message' -%}
        message_port_ptr d_msg_{{port['id']}};
    {% endif %}{% endfor %}
    {% for port in ports %}{% if port['domain'] == 'message' and port['direction'] == 'input' -%}
    virtual void handle_msg_{{port['id']}}(pmtf::pmt msg) {} //= 0;
    {% endif %}{% endfor%}
{% endmacro %}

{% macro parameter_declarations(parameters) -%}
{% if parameters -%}
public:
    {% for p in parameters -%}
        {% if p['container'] == 'vector' -%}
            {% if p['settable']%}
    virtual void set_{{p['id']}}(std::vector<{{p['dtype']}}> {{p['id']}}); 
            {% endif -%}
            {% if p['settable'] and not 'gettable' in p or p['gettable'] %}
    virtual std::vector<{{p['dtype']}}> {{p['id']}}();
            {% endif -%}
        {% else -%}
            {% if p['settable']%}
    virtual void set_{{p['id']}}({{get_linked_value(p['dtype'])}} {{p['id']}}); 
            {% endif -%}
            {% if p['settable'] and not 'gettable' in p or p['gettable'] %}
    virtual {{get_linked_value(p['dtype'])}} {{p['id']}}();
            {% endif -%}
        {% endif -%}
    {% endfor -%}
protected:
    enum params : uint32_t { {% for p in parameters -%}{#% if p['settable'] or p['gettable'] %#}id_{{p['id']}},{#% endif %#}{% endfor %} num_params };
{% for p in parameters -%}
{#% if p['settable'] or p['gettable'] %#}{% if 'serializable' not in p or p['serializable'] %}
    {% if 'string' in p['dtype'] %}
    pmt_sptr param_{{p['id']}};
    {% else %}
    pmt_sptr param_{{p['id']}};
    {% endif %}
    
{% endif %}
{% endfor -%}
{% endif -%}
{% endmacro %}

{% macro parameter_instantiations(parameters) -%}
{% if parameters -%}
    //d_param_str_map = {{"{"}} {% for p in parameters -%}{% if p['settable'] or p['gettable'] %}{{"{"}}"{{p['id']}}", id_{{p['id']}}{{"}"}},{% endif %} {% endfor -%}{{"}"}};
    d_param_str_map = {{"{"}} {% for p in parameters -%}{{"{"}}"{{p['id']}}", id_{{p['id']}}{{"}"}},{% endfor -%}{{"}"}};
    d_str_param_map = {{"{"}} {% for p in parameters -%}{{"{"}}id_{{p['id']}}, "{{p['id']}}"{{"}"}},{% endfor -%}{{"}"}};
{% for p in parameters -%}
{#% if p['settable'] or p['gettable']%#}{% if 'serializable' not in p or p['serializable'] %}
    {% if 'string' in p['dtype'] %}
    //param_{{p['id']}} = string_param::make(params::id_{{p['id']}}, 
    //    "{{p['id']}}"{{", args."+p['id'] if 'cotr' not in p or p['cotr']}});
    param_{{p['id']}} = std::make_shared<pmtf::pmt>(pmtf::string({{"args."+p['id'] if 'cotr' not in p or p['cotr']}}));
    {% else %}
    //param_{{p['id']}} = {{ 'scalar' if 'container' not in p else p['container']}}_param<{{p['dtype']}}>::make(params::id_{{p['id']}}, 
    //    "{{p['id']}}"{{", args."+p['id'] if 'cotr' not in p or p['cotr']}});
    {%if 'cotr' not in p or p['cotr']%}
    param_{{p['id']}} = std::make_shared<pmtf::pmt>({{'(int)' if p['is_enum']}}{{"args."+p['id']}});
    {%else%}
    param_{{p['id']}} = std::make_shared<pmtf::pmt>(pmtf::{{'scalar' if 'container' not in p else p['container']}}<{{p['dtype']}}>({%if 'default' in p %}{{p['default'] | string() | lower()}}{%endif%}));
    {%endif%}
    {% endif %}
    add_param("{{p['id']}}", d_param_str_map["{{p['id']}}"], param_{{p['id']}});
{% endif %}
{% endfor -%}
{% endif -%}
{% endmacro %}

{% macro block_docstring(doc,parameters,ports) -%}
{% if doc -%}
,R"({{doc['brief'] if 'brief' in doc}}
{{'\n' if 'brief' in doc and 'detail' in doc}}
{{doc['detail'] if 'detail' in doc}}
{% if ports %}
Ports: 
{% for port in ports -%}
  {{"  " + port['id']}} ({{port['direction']}} {{port['domain']}} port) [{{port['type']}}-{{port['size']}}]
{% endfor -%}
{% endif -%}
)"
{% endif -%}
{% endmacro%}

{% macro cpp_type_lookup(sigmf_type) %}
{%- set lu_type = sigmf_type -%}{%- if sigmf_type | is_list() -%}{%- set lu_type = sigmf_type[0] -%}{% endif %}
{%- set cpp_type = lu_type -%}
{%- if sigmf_type | trim() == 'cf32'-%}{%- set cpp_type = 'gr_complex' -%}
{%- elif sigmf_type | trim() == 'cf64'-%}{%- set cpp_type = 'gr_complexd' -%}
{%- elif sigmf_type | trim() == 'rf64'-%}{%- set cpp_type = 'double' -%}
{%- elif sigmf_type | trim() == 'rf32'-%}{%- set cpp_type = 'float' -%}
{%- elif sigmf_type | trim() == 'ri64'-%}{%- set cpp_type = 'std::int64_t' -%}
{%- elif sigmf_type | trim() == 'ri32'-%}{%- set cpp_type = 'std::int32_t' -%}
{%- elif sigmf_type | trim() == 'ri16'-%}{%- set cpp_type = 'std::int16_t' -%}
{%- elif sigmf_type | trim() == 'ri8'-%}{%- set cpp_type = 'std::int8_t' -%}
{%- elif sigmf_type | trim() == 'ru64'-%}{%- set cpp_type = 'std::uint64_t' -%}
{%- elif sigmf_type | trim() == 'ru32'-%}{%- set cpp_type = 'std::uint32_t' -%}
{%- elif sigmf_type | trim() == 'ru16'-%}{%- set cpp_type = 'std::uint16_t' -%}
{%- elif sigmf_type | trim() == 'ru8'-%}{%- set cpp_type = 'std::uint8_t' -%}
{%- endif -%}{{cpp_type}}
{%- endmacro -%}

{% macro suffix_lookup(type) %}
{%- set suffix = type -%}
{%- if type | trim() == 'cf32'-%}{%- set suffix = 'c' -%}
{%- elif type | trim() == 'cf64'-%}{%- set suffix = 'z' -%}
{%- elif type | trim() == 'rf64'-%}{%- set suffix = 'd' -%}
{%- elif type | trim() == 'rf32'-%}{%- set suffix = 'f' -%}
{%- elif type | trim() == 'ri64'-%}{%- set suffix = 'l' -%}
{%- elif type | trim() == 'ri32'-%}{%- set suffix = 'i' -%}
{%- elif type | trim() == 'ri16'-%}{%- set suffix = 's' -%}
{%- elif type | trim() == 'ri8'-%}{%- set suffix = 'b' -%}
{%- elif type | trim() == 'ru64'-%}{%- set suffix = 'l' -%}
{%- elif type | trim() == 'ru32'-%}{%- set suffix = 'i' -%}
{%- elif type | trim() == 'ru16'-%}{%- set suffix = 's' -%}
{%- elif type | trim() == 'ru8'-%}{%- set suffix = 'b' -%}
{%- endif -%}{{suffix}}
{%- endmacro -%}

{%- macro typekey_suffix(type, id, ports) -%}
{%- set suffix = suffix_lookup(type) -%}
{%- set suffix_accum = suffix_lookup(type) -%}
{%- set vars = {'ports': False} -%}
{%- if type | is_list() -%}{{type[1]}}
{%- else -%}
    {%- for p in ports -%}
    {%- if '/' in p['type'] | string() -%}
    {%- set list1 = p['type'].split('/') -%}
    {%- if list1[0] == 'typekeys' -%}{%- if list1[1] == id -%}{{suffix_lookup(type)}}{% if vars.update({'ports': True}) %} {% endif %}{%- endif -%}{%- endif -%}
    {%- endif -%}
    {%- endfor -%}
    {%- if not vars.ports -%}{{suffix_lookup(type)}}{%- endif -%}
{%- endif -%}
{%- endmacro -%}
{#%- set suffix = suffix ~ suffix_lookup(type) -%#}
