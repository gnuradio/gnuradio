#pragma once

#include <pybind11/embed.h>
#include <pybind11/pybind11.h> // must be first
#include <pybind11/stl.h>
#include <pybind11/complex.h>
namespace py = pybind11;
using namespace py::literals;

#include <gnuradio/{{module}}/{{block}}.h>

namespace gr {
namespace {{module}} {

// This is the artifact of pybind11 fvisibility settings
#pragma GCC visibility push(hidden)
class {{block}}_pyshell : public {{block}}
{
private:
    py::object _pyimpl;
public:
    {{block}}_pyshell(const std::string& impl, const typename {{block}}::block_args& args) : {{blocktype}}("{{block}}", "{{module}}"), {{block}}(args)
    {
        py::module_ mod = py::module_::import(std::string("gnuradio.{{module}}." + impl).c_str());
        auto kwargs = py::dict(
        {%- if parameters -%}
        {%- for p in parameters -%}
        {%- if 'cotr' not in p or p['cotr'] %}
        "{{p['id']}}"_a = args.{{p['id']}}{{"," if not loop.last}}
        {%- endif -%}
        {%- endfor -%}
        {%- endif -%});

        _pyimpl = mod.attr("{{block}}")(dynamic_cast<{{block}}*>(this), **kwargs);
    
    }

{% if blocktype != "hier_block" %}
    work_return_t
    work(work_io& wio) override
    {
        py::gil_scoped_acquire acquire;

        py::object ret = _pyimpl.attr("work")(&wio);

        return ret.cast<work_return_t>();
    }

    bool start(void)
    {
        py::gil_scoped_acquire acquire;
        if (py::hasattr(_pyimpl, "start")) {
            py::object ret = _pyimpl.attr("start")();
            return ret.cast<bool>() && block::start();
        }
        else
            return block::start();
    }

    bool stop(void)
    {
        py::gil_scoped_acquire acquire;
        if (py::hasattr(_pyimpl, "stop")) {
            py::object ret = _pyimpl.attr("stop")();
            return ret.cast<bool>() && block::stop();
        }
        else
            return block::stop();
    }

{% endif %}

    {% set vars = {'py_impl': False} %}
    {% for impl in implementations -%}
    {% if 'lang' in impl and impl['lang'] == 'python' and not vars.py_impl -%}
    py::object py_method(const std::string& name, py::tuple args = py::tuple(), py::dict kwargs = py::dict())
    {
        py::gil_scoped_acquire acquire;
        if (py::hasattr(_pyimpl, name.c_str())) {
            py::object ret = _pyimpl.attr(name.c_str())(*args, **kwargs);
            return ret;
        }

        throw py::error_already_set();

    }
    {% if vars.update({'py_impl': True}) %} {% endif %}{% endif %}
    {%- endfor -%}

{% for port in ports %}{% if port['domain'] == 'message' and port['direction'] == 'input' -%}
    virtual void handle_msg_{{port['id']}}(pmtf::pmt msg) override
    {
        py::gil_scoped_acquire acquire;
        if (py::hasattr(_pyimpl, "{{"handle_msg_" + port['id']}}")) {
            py::object ret = _pyimpl.attr("{{"handle_msg_" + port['id']}}")(msg);
        }
        else
            throw std::runtime_error("Message port handler not found");

    } 
{% endif %}{% endfor%}

};
#pragma GCC visibility pop

} // namespace {{module}}
} // namespace gr
