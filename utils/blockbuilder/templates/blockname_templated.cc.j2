{% import 'macros.j2' as macros -%}
{{ macros.header() }}
#include <gnuradio/{{module}}/{{block}}.h>
#include <gnuradio/registry.h>
#include <nlohmann/json.hpp>

namespace gr {
namespace {{module}} {

template <{% for key in typekeys -%}{{key['type']}} {{key['id']}}{{ ", " if not loop.last }}{%endfor%}>
typename {{block}}<{% for key in typekeys -%}{{key['id']}}{{ ", " if not loop.last }}{%endfor%}>::sptr {{block}}<{% for key in typekeys -%}{{key['id']}}{{ ", " if not loop.last }}{%endfor%}>::make(const block_args& args, available_impl impl)
{
    {% set vars = {'pyshell': False} %}
    switch (impl) {
    {% for impl in implementations %}
    {% if 'lang' not in impl or impl['lang'] == 'cpp' -%}
    #ifdef HAVE_{{ impl['id'] | upper }}
    case available_impl::{{ impl['id'] | upper }}:
        return make_{{ impl['id'] | lower }}(args);
        break;
    #endif
    {% elif 'lang' in impl and impl['lang'] == 'python' -%}
    case available_impl::{{ impl['id'] | upper }}:
        return make_pyshell("{{ impl['id'] | lower }}", args);
        break;
    {% if vars.update({'pyshell': True}) %} {% endif %}
    {% endif -%}
    {% endfor %}

    default:
        throw std::invalid_argument(
            "invalid implementation specified");
    }
}

template <{% for key in typekeys -%}{{key['type']}} {{key['id']}}{{ ", " if not loop.last }}{%endfor%}>
typename {{block}}<{% for key in typekeys -%}{{key['id']}}{{ ", " if not loop.last }}{%endfor%}>::sptr {{block}}<{% for key in typekeys -%}{{key['id']}}{{ ", " if not loop.last }}{%endfor%}>::make_from_params(const std::string& json_str, available_impl impl)
{
    block_args args;

    // Parse the json string
    using json = nlohmann::json;
    auto json_obj = json::parse(json_str);

    {% for p in parameters -%}
    {% if ('cotr' not in p or p['cotr']) and ('serializable' not in p or p['serializable'])%}
    args.{{p['id']}} = {{'('+p['dtype']|cpp_type+')' if p['is_enum']}}pmtf::get_as<{{ 'int' if p['is_enum'] else p['dtype']|cpp_type(vec=p['container']=='vector')}}>(deserialize_param_to_pmt(json_obj["{{p['id']}}"].get<std::string>()));
    {% endif %}
    {% endfor -%}

    return make(args, impl);
}

{% for impl in implementations %}
{% if 'lang' not in impl or impl['lang'] == 'cpp' -%}
template <{% for key in typekeys -%}{{key['type']}} {{key['id']}}{{ ", " if not loop.last }}{%endfor%}>
typename {{block}}<{% for key in typekeys -%}{{key['id']}}{{ ", " if not loop.last }}{%endfor%}>::sptr {{block}}<{% for key in typekeys -%}{{key['id']}}{{ ", " if not loop.last }}{%endfor%}>::make_from_params_{{impl['id']}}(std::map<std::string, pmtf::pmt>& param_map)
{
    block_args args;

    {% for p in parameters -%}
    {% if ('cotr' not in p or p['cotr']) and ('serializable' not in p or p['serializable'])%}
    args.{{p['id']}} = {{'('+p['dtype']|cpp_type+')' if p['is_enum']}}pmtf::get_as<{{ 'int' if p['is_enum'] else p['dtype']|cpp_type(vec=p['container']=='vector')}}>(param_map["{{p['id']}}"]);
    {% endif %}
    {% endfor -%}

    return make(args, available_impl::{{impl['id'] | upper }});
}
{% endif %}
{% endfor %}


template <{% for key in typekeys -%}{{key['type']}} {{key['id']}}{{ ", " if not loop.last }}{%endfor%}>
{{block}}<{% for key in typekeys -%}{{key['id']}}{{ ", " if not loop.last }}{%endfor%}>::{{block}}(const block_args& args) : {{blocktype}}("{{ block }}", "{{ module }}") {
 {{ macros.ports(ports, parameters, typekeys) }}
 {{ macros.parameter_instantiations(parameters) }}

}

// Settable Parameters
{% for p in parameters -%}
{% if p['settable']%}
template <{% for key in typekeys -%}{{key['type']}} {{key['id']}}{{ ", " if not loop.last }}{%endfor%}>
void {{block}}<{% for key in typekeys -%}{{key['id']}}{{ ", " if not loop.last }}{%endfor%}>::set_{{p['id']}}({{p['dtype'] | cpp_type(vec=p['container']=='vector')}} {{p['id']}})
{
    return request_parameter_change(params::id_{{p['id']}}, {{"(int)" if p['is_enum']}}{{p['id']}});
}
{% endif -%}
{% if p['settable'] and not 'gettable' in p or p['gettable'] %}
template <{% for key in typekeys -%}{{key['type']}} {{key['id']}}{{ ", " if not loop.last }}{%endfor%}>
{{ p['dtype']|cpp_type(vec=p['container']=='vector')}} {{block}}<{% for key in typekeys -%}{{key['id']}}{{ ", " if not loop.last }}{%endfor%}>::{{p['id']}}()
{
{% if p['is_enum'] %}
{% if 'container' in p and p['container'] == 'vector' %}
    return pmtf::get_as<{{ 'std::vector<int>' }}>(request_parameter_query(params::id_{{p['id']}}));
{% else %}
    return ({{p['dtype']|cpp_type}}) pmtf::get_as<int>(request_parameter_query(params::id_{{p['id']}}));
{% endif %}
{% else %}
    return pmtf::get_as<{{ p['dtype']|cpp_type(vec=p['container']=='vector')}}>(request_parameter_query(params::id_{{p['id']}}));
{% endif %}
}
{% endif %}
{% endfor -%}

{%if typekeys | length == 1 -%}
{%set key1 = typekeys|first %}
{% for opt in key1['options'] -%}

template <>
std::string {{block}}<{{ opt | cpp_type }}>::suffix(){ return "_{{macros.typekey_suffix(opt, key1['id'],ports)}}"; }
template class {{block}}<{{ opt | cpp_type }}>;
{% if parameters %}{% for p in parameters -%}
[[maybe_unused]] static auto reg_{{module}}_{{block}}_{{ macros.typekey_suffix(opt, key1['id'],ports) }}_{{p['id']}} = gr::registry::register_parameter("{{module}}","{{block}}_{{ macros.typekey_suffix(opt, key1['id'],ports) }}", 
{
  "{{p['id']}}",
  "{{p['label']}}",
  "{{p['dtype']|typekey_lookup({key1['id']:opt})}}",
  {{p['settable']|lower if p['settable'] else 'false'}},
  {{p['gettable']|lower if p['gettable'] else 'true'}},
  "{{p['container'] if p['container'] else 'scalar'}}",
  {{p['cotr']|lower if p['cotr'] else 'true'}},
  {{p['is_enum']|lower if p['is_enum'] else 'false'}},
});
{% endfor -%}{% endif %}
{% for impl in implementations -%}
{% if 'lang' not in impl or impl['lang'] == 'cpp' -%}
[[maybe_unused]] static auto reg_{{module}}_{{block}}_{{ macros.typekey_suffix(opt, key1['id'],ports) }}_{{impl['id']}} = gr::registry::register_class("{{module}}","{{block}}_{{ macros.typekey_suffix(opt, key1['id'],ports) }}","{{impl['id']}}",{{block}}<{{ opt|cpp_type }}>::make_from_params_{{impl['id']}});
{% endif -%}
{% endfor -%}
{% endfor -%}
{% elif typekeys | length == 2 -%}
{%set key1 = typekeys|first %}
{%set key2 = typekeys|last %}
{% for opt1 in key1['options'] -%}
{% for opt2 in key2['options'] -%}
{% if type_inst -%}
{% for typev in type_inst -%}
{% if opt1 == typev['value'][0] and opt2 == typev['value'][1] -%}
template <>
std::string {{block}}<{{ opt1 | cpp_type}}, {{ opt2 | cpp_type}}>::suffix(){ return "_{{macros.typekey_suffix(opt1, key1['id'],ports)}}{{macros.typekey_suffix(opt2, key2['id'],ports)}}"; }
template class {{block}}<{{ opt1 | cpp_type}}, {{ opt2 | cpp_type}}>;
{% if parameters %}{% for p in parameters -%}
[[maybe_unused]] static auto reg_{{module}}_{{block}}_{{ macros.typekey_suffix(opt1, key1['id'],ports) }}{{ macros.typekey_suffix(opt2, key2['id'],ports) }}_{{p['id']}} = gr::registry::register_parameter("{{module}}","{{block}}_{{ macros.typekey_suffix(opt1, key1['id'],ports) }}{{ macros.typekey_suffix(opt2, key2['id'],ports) }}", 
{
  "{{p['id']}}",
  "{{p['label']}}",
  "{{p['dtype']|typekey_lookup({key1['id']:opt1, key2['id']:opt2})}} }}",
  {{p['settable']|lower if p['settable'] else 'false'}},
  {{p['gettable']|lower if p['gettable'] else 'true'}},
  "{{p['container'] if p['container'] else 'scalar'}}",
  {{p['cotr']|lower if p['cotr'] else 'true'}},
  {{p['is_enum']|lower if p['is_enum'] else 'false'}},
});
{% endfor -%}{% endif %}
{% for impl in implementations -%}{% if 'lang' not in impl or impl['lang'] == 'cpp' -%}
[[maybe_unused]] static auto reg_{{module}}_{{block}}_{{ macros.typekey_suffix(opt1, key1['id'],ports) }}{{ macros.typekey_suffix(opt2, key2['id'],ports) }}_{{impl['id']}} = gr::registry::register_class("{{module}}","{{block}}_{{ macros.typekey_suffix(opt1, key1['id'],ports) }}{{ macros.typekey_suffix(opt2, key2['id'],ports) }}","{{impl['id']}}",{{block}}<{{ opt1|cpp_type }}, {{ opt2|cpp_type }}>::make_from_params_{{impl['id']}});
{% endif -%}{% endfor -%}
{% endif %}
{% endfor %}
{% else %}
template <>
std::string {{block}}<{{ opt1 | cpp_type}}, {{ opt2 | cpp_type}}>::suffix(){ return "_{{macros.typekey_suffix(opt1, key1['id'],ports)}}{{macros.typekey_suffix(opt2, key2['id'],ports)}}"; }
template class {{block}}<{{ opt1 | cpp_type}}, {{ opt2 | cpp_type}}>;
{% if parameters %}{% for p in parameters -%}
[[maybe_unused]] static auto reg_{{module}}_{{block}}_{{ macros.typekey_suffix(opt1, key1['id'],ports) }}{{ macros.typekey_suffix(opt2, key2['id'],ports) }}_{{p['id']}} = gr::registry::register_parameter("{{module}}","{{block}}_{{ macros.typekey_suffix(opt1, key1['id'],ports) }}{{ macros.typekey_suffix(opt2, key2['id'],ports) }}", 
{
  "{{p['id']}}",
  "{{p['label']}}",
  "{{p['dtype']|typekey_lookup({key1['id']:opt1, key2['id']:opt2})}} }}",
  {{p['settable']|lower if p['settable'] else 'false'}},
  {{p['gettable']|lower if p['gettable'] else 'true'}},
  "{{p['container'] if p['container'] else 'scalar'}}",
  {{p['cotr']|lower if p['cotr'] else 'true'}},
  {{p['is_enum']|lower if p['is_enum'] else 'false'}},
});
{% endfor -%}{% endif %}
{% for impl in implementations -%}{% if 'lang' not in impl or impl['lang'] == 'cpp' -%}
[[maybe_unused]] static auto reg_{{module}}_{{block}}_{{ macros.typekey_suffix(opt1, key1['id'],ports) }}{{ macros.typekey_suffix(opt2, key2['id'],ports) }}_{{impl['id']}} = gr::registry::register_class("{{module}}","{{block}}_{{ macros.typekey_suffix(opt1, key1['id'],ports) }}{{ macros.typekey_suffix(opt2, key2['id'],ports) }}","{{impl['id']}}",{{block}}<{{ opt1|cpp_type }}, {{ opt2|cpp_type }}>::make_from_params_{{impl['id']}});
{% endif -%}{% endfor -%}
{% endif %}
{% endfor -%}
{% endfor -%}
{% else %}
{%set key1 = typekeys|first %}
{%set key2 = typekeys[1]%}
{%set key3 = typekeys|last %}
{% for opt1 in key1['options'] -%}
{% for opt2 in key2['options'] -%}
{% for opt3 in key3['options'] -%}
{% if type_inst -%}
{% for typev in type_inst -%}
{% if opt1 == typev['value'][0] and opt2 == typev['value'][1] and opt3 == typev['value'][2] -%}
template <>
std::string {{block}}<{{ opt1 | cpp_type}}, {{ opt2 | cpp_type}}, {{ opt3 | cpp_type}}>::suffix(){ return "_{{macros.typekey_suffix(opt1, key1['id'],ports)}}{{macros.typekey_suffix(opt2, key2['id'],ports)}}{{macros.typekey_suffix(opt3, key3['id'],ports)}}"; }
template class {{block}}<{{ opt1 | cpp_type}}, {{ opt2 | cpp_type}}, {{ opt3 | cpp_type}}>;
{% endif -%}
{% endfor -%}
{% else %}
template <>
std::string {{block}}<{{ opt1 | cpp_type}}, {{ opt2 | cpp_type}}, {{ opt3 | cpp_type}}>::suffix(){ return "_{{macros.typekey_suffix(opt1, key1['id'],ports)}}{{macros.typekey_suffix(opt2, key2['id'],ports)}}{{macros.typekey_suffix(opt3, key3['id'],ports)}}"; }
template class {{block}}<{{ opt1 | cpp_type}}, {{ opt2 | cpp_type}}, {{ opt3 | cpp_type}}>;
{% endif %}
{% endfor -%}
{% endfor -%}
{% endfor -%}
{% endif -%}
} // namespace {{ module }}
} // namespace gr
